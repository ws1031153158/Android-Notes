# 工厂方法
定义：  
父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。  
注意：  
具有共同的基类或者接口时， 子类才能返回不同类型的实例， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。  
场景：  
1.无法预知对象确切类别及其依赖关系时， 可使用工厂方法。  
2.希望能扩展库或框架的内部组件， 可使用工厂方法。  
3.复用现有对象来节省系统资源， 可使用工厂方法。  
优点：  
 1.避免创建者和具体实例耦合。  
2. 单一职责原则，代码更容易维护。  
3. 开闭原则，无需更改现有代码， 可以在引入新的产品类型。  
缺点：  
需要引入许多新的子类， 代码更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。
# 抽象工厂
定义：   
创建一系列相关的对象， 而无需指定其具体类。  
注意：  
一般情况下，如果客户端仅接触抽象接口，  应用程序会在初始化阶段创建具体工厂对象。 在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。  
场景：  
1.代码需要与多个不同系列的相关产品交互， 但无法提前获取相关信息， 或出于对未来扩展性的考虑， 不希望代码基于产品的具体类进行构建，可以使用抽象工厂。  
2.如果有一个基于一组抽象方法的类， 其主要功能因此变得不明确，可以使用抽象工厂模式。
优点：  
1.可以确保同一工厂生成的对象相互匹配。    
2.可以避免客户端和具体产品代码耦合。  
3.单一职责原则，可以将产品生成代码抽取到同一位置， 使得代码易于维护。   
4.开闭原则，向应用程序中引入新产品变体时， 你无需修改客户端代码。  
缺点： 
需要向应用中引入众多接口和类， 代码更加复杂。
# 单例
定义：     
保证一个类只有一个实例， 并提供一个访问该实例的全局节点。  
注意：    
认构造函数设为私有， 防止其他对象使用单例类的 new 运算符。  
场景：    
1.程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。  
2.需要更加严格地控制全局变量， 可以使用单例模式。  
优点：    
1.可以保证一个类只有一个实例。  
2.获得了一个指向该实例的全局访问节点。  
2.仅在首次请求单例对象时对其进行初始化。  
缺点：     
1.违反了单一职责原则。 该模式同时解决了两个问题。  
2.单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。  
3.该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。  
# 原型
定义：   
能够复制已有对象， 而又无需使代码依赖它们所属的类。  
注意：    
支持克隆的对象即为原型，有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。  
场景：    
1.需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。  
2.子类的区别仅在于其对象的初始化方式， 可以使用该模式来减少子类的数量。  
优点：    
1.可以克隆对象， 而无需与它们所属的具体类耦合。  
2.可以克隆预生成原型， 避免反复运行初始化代码。  
3.可以更方便地生成复杂对象。  
4.可以用继承以外的方式来处理复杂对象的不同配置。  
缺点：   
克隆包含循环引用的复杂对象可能会非常麻烦。  
# 建造者
定义：   
能够分步骤创建复杂对象。 该模式允许使用相同的创建代码生成不同类型和形式的对象。  
注意：   
通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。  
场景：  
1.使用生成器模式可避免重叠构造函数的出现。  
2.使用代码创建不同形式的对象时， 可使用生成器模式。  
3.使用生成器构造组合树或其他复杂对象。  
优点：  
1.可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。  
2.生成不同形式的产品时， 可以复用相同的制造代码。  
3.单一职责原则。 可以将复杂构造代码从产品的业务逻辑中分离出来。  
缺点： 
由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。
