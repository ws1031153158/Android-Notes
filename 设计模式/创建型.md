# 工厂方法
定义：  
父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。  
注意：  
具有共同的基类或者接口时， 子类才能返回不同类型的实例， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。  
场景：  
1.无法预知对象确切类别及其依赖关系时， 可使用工厂方法。  
2.希望能扩展库或框架的内部组件， 可使用工厂方法。  
3.复用现有对象来节省系统资源， 可使用工厂方法。  
优点：  
 1.避免创建者和具体实例耦合。  
2. 单一职责原则，代码更容易维护。  
3. 开闭原则，无需更改现有代码， 可以在引入新的产品类型。  
缺点：  
需要引入许多新的子类， 代码更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。
# 抽象工厂
定义：   
创建一系列相关的对象， 而无需指定其具体类。  
注意：  
一般情况下，如果客户端仅接触抽象接口，  应用程序会在初始化阶段创建具体工厂对象。 在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。  
场景：  
1.代码需要与多个不同系列的相关产品交互， 但无法提前获取相关信息， 或出于对未来扩展性的考虑， 不希望代码基于产品的具体类进行构建，可以使用抽象工厂。  
2.如果有一个基于一组抽象方法的类， 其主要功能因此变得不明确，可以使用抽象工厂模式。
优点：  
1.可以确保同一工厂生成的对象相互匹配。    
2.可以避免客户端和具体产品代码耦合。  
3.单一职责原则，可以将产品生成代码抽取到同一位置， 使得代码易于维护。   
4.开闭原则，向应用程序中引入新产品变体时， 你无需修改客户端代码。  
缺点： 
需要向应用中引入众多接口和类， 代码更加复杂。
# 单例
定义：     
注意：    
场景：    
优点：    
缺点：     
# 原型
定义：   
注意：    
场景：    
优点：    
缺点：   
# 建造者
定义：   
注意：   
场景：  
优点：  
缺点： 
