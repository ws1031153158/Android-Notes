# 装饰
定义：     
允许通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。  
注意：    
在运行时改变容器的行为。 一个对象可以使用多个类的行为， 包含多个指向其他对象的引用， 并将各种工作委派给引用对象，客户端代码必须将基础通知器放入一系列自己所需的装饰中。   
场景：    
1.希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。  
2.用继承来扩展对象行为的方案难以实现或者根本不可行， 可以使用该模式。  
优点：    
1.无需创建新子类即可扩展对象的行为。  
2.可以在运行时添加或删除对象的功能。  
3.可以用多个装饰封装对象来组合几种行为。  
4.单一职责原则，可以将实现了许多不同行为的一个大类拆分为多个较小的类。  
缺点：     
1.在封装器栈中删除特定封装器比较困难。  
2.实现行为不受装饰栈顺序影响的装饰比较困难。  
3.各层的初始化配置代码看上去可能会很糟糕。  
# 外观
定义：     
为程序库、 框架或其他复杂类提供一个简单的接口。  
注意：    
必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。  
子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。  
场景：    
1.需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 可以使用外观模式。  
2.需要将子系统组织为多层结构， 可以使用外观。  
优点：    
可以让自己的代码独立于复杂子系统。  
缺点：     
外观可能成为与程序中所有类都耦合的上帝对象。
# 桥接
定义：     
将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。  
注意：    
将继承改为组合的方式来解决问题，抽象部分不完成任何具体的工作， 需要将工作委派给实现部分层。  
场景：    
1.想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。  
2.希望在几个独立维度上扩展一个类， 可使用该模式。  
3.需要在运行时切换不同实现方法， 可使用桥接模式。  
优点：    
 1.可以创建与平台无关的类和程序。  
2.客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。  
3.开闭原则，可以新增抽象部分和实现部分， 且它们之间不会相互影响。  
4.单一职责原则，抽象部分专注于处理高层逻辑， 实现部分处理平台细节。    
缺点：     
对高内聚的类使用该模式可能会让代码更加复杂。
# 适配器
定义：     
使接口不兼容的对象能够相互合作。  
注意：    
可以创建一个双向适配器来实现双向转换调用。    
场景：    
1.希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。  
2.需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。  
优点：    
1.单一职责原则，可以将接口或数据转换代码从程序主要业务逻辑中分离。  
2.开闭原则，只要客户端代码通过客户端接口与适配器进行交互， 就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。  
缺点：     
代码整体复杂度增加， 因为需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。
# 代理
定义：     
能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。    
注意：    
通常情况下， 代理会对其服务对象的整个生命周期进行管理。  
场景：    
1.延迟初始化。  
2.访问控制。  
3.本地执行远程服务，适用于服务对象位于远程服务器上的情形。    
4.记录日志请求，适用于当你需要保存对于服务对象的请求历史记录时。    
5.缓存请求结果，适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。    
5.智能引用，可在没有客户端使用某个重量级对象时立即销毁该对象。  
优点：    
1.可以在客户端毫无察觉的情况下控制服务对象。  
2.如果客户端对服务对象的生命周期没有特殊要求， 可以对生命周期进行管理。  
3.即使服务对象还未准备好或不存在， 代理也可以正常工作。  
4.开闭原则，可以在不对服务或客户端做出修改的情况下创建新代理。  
缺点：     
1.代码可能会变得复杂， 因为需要新建许多类。  
2.服务响应可能会延迟。
# 享元
定义：     
摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 能在有限的内存容量中载入更多对象。  
注意：    
仅存储内在状态的对象称为享元（对象的常量数据通常被称为内在状态， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为外在状态）。    
享元对象可在不同的情景中使用， 必须确保其状态不能被修改。 享元类的状态只能由构造函数的参数进行一次性初始化， 它不能对其他对象公开其设置器或公有成员变量。  
场景：    
仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。  
优点：    
如果程序中有很多相似对象， 可以节省大量内存。  
缺点：     
1.可能需要牺牲执行速度来换取内存， 每次调用享元方法时都需要重新计算部分情景数据。  
2.代码会变得更加复杂。 
