# 策略
定义：     
注意：    
场景：    
优点：    
缺点：     
# 观察者
定义：     
注意：    
场景：    
优点：    
缺点：     
# 中介者
定义：     
注意：    
场景：    
优点：    
缺点：     
# 状态
定义：     
注意：    
场景：    
优点：    
缺点：     
# 责任链
定义：     
允许将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。  
注意：    
处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。  
场景：    
1.当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。  
2.当必须按顺序执行多个处理者时， 可以使用该模式。  
3.所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。  
优点：    
1.可以控制请求处理的顺序。  
2.单一职责原则，可对发起操作和执行操作的类进行解耦。  
3.开闭原则，可以在不更改现有代码的情况下在程序中新增处理者。  
缺点：     
部分请求可能未被处理。
# 命令
定义：     
可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。  
注意：    
程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。  
客户端必须按照以下顺序来初始化对象：创建接收者 -> 创建命令， 如有需要可将其关联至接收者 -> 创建发送者并将其与特定命令关联  
场景：    
1.需要通过操作来参数化对象， 可使用命令模式。  
2.将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。  
3.想要实现操作回滚功能， 可使用命令模式。  
优点：    
1.单一职责原则,可以解耦触发和执行操作的类。  
2.开闭原则,可以在不修改已有客户端代码的情况下在程序中创建新的命令。  
3.可以实现撤销和恢复功能。  
4.可以实现操作的延迟执行。  
5.可以将一组简单命令组合成一个复杂命令。  
缺点：     
代码可能会变得更加复杂， 因为在发送者和接收者之间增加了一个全新的层次。
# 迭代器
定义：     
能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。  
注意：    
所有迭代器必须实现相同的接口。    
场景：    
1.当集合背后为复杂的数据结构， 且希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。  
2.代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。    
优点：    
1.单一职责原则，通过将体积庞大的遍历算法代码抽取为独立的类， 可对客户端代码和集合进行整理。  
2.开闭原则，可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。  
3.可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。  
4.相似的， 可以暂停遍历并在需要时继续。  
缺点：    
1.如果程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。  
2.对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。
# 备忘录
定义：     
注意：    
场景：    
优点：    
缺点：     
# 访问者
定义：     
注意：    
场景：    
优点：    
缺点：     
# 模板方法
定义：     
注意：    
场景：    
优点：    
缺点：     
# 解释器
定义：     
注意：    
场景：    
优点：    
缺点：     
