# 策略
定义：     
定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。  
注意：    
原始类必须包含一个成员变量来存储对于每种策略的引用。  
场景：    
1.使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。  
2.有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。  
3.算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。  
优点：    
1.可以在运行时切换对象内的算法。  
2.可以将算法的实现和使用算法的代码隔离开来。  
3.可以使用组合来代替继承。  
4.开闭原则，无需对上下文进行修改就能够引入新的策略。  
缺点：     
1.如果算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。  
2.客户端必须知晓策略间的不同——它需要选择合适的策略。  
# 观察者
定义：     
定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。  
注意：    
发布者必须仅通过订阅者接口与它们进行交互。  
场景：    
1.对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。  
2.应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。  
优点：    
1.开闭原则，无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。  
2.可以在运行时建立对象之间的联系。  
缺点：     
订阅者的通知顺序是随机的。
# 中介者
定义：     
减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。   
注意：    
具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。  
场景：    
1.一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。   
2.组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。   
3.为了能在不同情景下复用一些基本行为， 导致需要被迫创建大量组件子类时， 可使用中介者模式。  
优点：    
1.单一职责原则，可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。   
2.开闭原则，无需修改实际组件就能增加新的中介者。  
3.可以减轻应用中多个组件间的耦合情况。  
4.可以更方便地复用各个组件。  
缺点：     
一段时间后， 中介者可能会演化成为上帝对象。
# 状态
定义：     
在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。  
注意：    
所有状态类都必须遵循同样的接口， 而且上下文必须仅通过接口与这些对象进行交互。  
场景：    
1.对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。  
2.类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。  
3.相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。  
优点：    
1.单一职责原则，将与特定状态相关的代码放在单独的类中。  
2.开闭原则，无需修改已有状态类和上下文就能引入新状态。  
3.通过消除臃肿的状态机条件语句简化上下文代码。  
缺点：     
如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。
# 责任链
定义：     
允许将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。  
注意：    
处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。  
场景：    
1.当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。  
2.当必须按顺序执行多个处理者时， 可以使用该模式。  
3.所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。  
优点：    
1.可以控制请求处理的顺序。  
2.单一职责原则，可对发起操作和执行操作的类进行解耦。  
3.开闭原则，可以在不更改现有代码的情况下在程序中新增处理者。  
缺点：     
部分请求可能未被处理。
# 命令
定义：     
可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。  
注意：    
程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。  
客户端必须按照以下顺序来初始化对象：创建接收者 -> 创建命令， 如有需要可将其关联至接收者 -> 创建发送者并将其与特定命令关联  
场景：    
1.需要通过操作来参数化对象， 可使用命令模式。  
2.将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。  
3.想要实现操作回滚功能， 可使用命令模式。  
优点：    
1.单一职责原则,可以解耦触发和执行操作的类。  
2.开闭原则,可以在不修改已有客户端代码的情况下在程序中创建新的命令。  
3.可以实现撤销和恢复功能。  
4.可以实现操作的延迟执行。  
5.可以将一组简单命令组合成一个复杂命令。  
缺点：     
代码可能会变得更加复杂， 因为在发送者和接收者之间增加了一个全新的层次。
# 迭代器
定义：     
能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。  
注意：    
所有迭代器必须实现相同的接口。    
场景：    
1.当集合背后为复杂的数据结构， 且希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。  
2.代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。    
优点：    
1.单一职责原则，通过将体积庞大的遍历算法代码抽取为独立的类， 可对客户端代码和集合进行整理。  
2.开闭原则，可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。  
3.可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。  
4.相似的， 可以暂停遍历并在需要时继续。  
缺点：    
1.如果程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。  
2.对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。
# 备忘录
定义：     
允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。  
注意：    
将备忘录类设为不可变。 备忘录只能通过构造函数一次性接收数据。  
场景：    
1.需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。  
2.直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。  
优点：    
1.可以在不破坏对象封装情况的前提下创建对象状态快照。  
2.可以通过让负责人维护原发器状态历史记录来简化原发器代码。  
缺点：     
1.如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。  
2.负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。  
3.绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。  
# 访问者
定义：     
将算法与其所作用的对象隔离开来。  
注意：    
客户端必须创建访问者对象并通过 “接收” 方法将其传递给元素。  
场景：    
1.需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。  
2.可使用访问者模式来清理辅助行为的业务逻辑。  
3.当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。  
优点：    
1.开闭原则，可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。  
2.单一职责原则，可将同一行为的不同版本移到同一个类中。  
3.访问者对象可以在与各种对象交互时收集一些有用的信息，要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。  
缺点：     
1.每次在元素层次结构中添加或移除一个类时， 都要更新所有的访问者。  
2.在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。  
# 模板方法
定义：     
在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。  
注意：    
可考虑在算法的关键步骤之间添加钩子。  
场景：    
1.只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。  
2.多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。  
优点：    
1.可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。  
2.可将重复代码提取到一个超类中。  
缺点：       
1.部分客户端可能会受到算法框架的限制。  
2.通过子类抑制默认步骤实现可能会导致违反里氏替换原则。  
3.模板方法中的步骤越多， 其维护工作就可能会越困难。
