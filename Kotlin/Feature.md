# 扩展函数
## 内联
let：一般与 .？一起使用，代码块内部是对调用对象的各个方法的访问，it 替代该对象，底层为 inLine 的扩展函数 + lambda 结构，返回值为函数块的最后一行或指定 return 表达式  
with：和 let 类似，内部 this 指代调用对象（可忽略），该结构返回最后一行或指定的 return 表达式。传入两个参数，调用对象和一个 lambda 体，若最后一个参数是函数则可以放在括号外，常用于调用同一个对象的多个方法。（tip：with 不是扩展函数）  
apply：和 run 类似，返回值不同，返回传入对象本身（返回 this），一般用于对象初始化，对属性复制，或动态 inflate 一个 view 给 view 绑定数据  
also：和 let 类似，it 指代，返回当前的这个对象（返回 this），一般可用于多个扩展函数链式调用  
run：可看做 let 和 with 的结合体，只接受一个 lambda 函数作为参数。可以判空，且也是由 this 指代（可省略），以闭包形式返回最后一行代码的值。
## 自定义
在类的外面定义扩展函数，可在类内部/外部调用，无需修改类本身即可实现功能的扩展，不会作为成员添加到类中，可在接口中定义扩展，可定义成员扩展（不支持引用，且多个隐式访问可读性差）  
Class.function，本质是静态函数，编译器将扩展函数转化为静态函数的调用
# When
等同于 switch，且类型推导让我们无需指定返回值类型也不需要写 break，可以匹配任一对象，没有限制
# By
一种委托机制：  
类委托：类的具体实现委托给另一个类（by 之后的类）完成，通常用于指定一个实现类，去实现接口中的公共方法，类的构造函数要传入这个要实现类对象，一般为了解耦和复用，将一个接口交给一个对象（类）实现。  
属性委托：属性值不是在类中直接进行定义，而是将其托付给一个代理类，属性的 get/set 方法被委托给 by 之后的对象的 getValue/setValue 方法（必须提供），特殊的有 by lazy，懒加载，传入一个加载模式，一般为 LazyThreadSafetyMode.SYNCHRONIZED，保证线程安全，只会在第一次使用时初始化一次。  
lateinit：延迟加载，只是编译器不会对初始化做检测，而 lazy 是一个内联高阶函数，传入自身来做一些初始化判断
# Constructor
支持类命名时指定构造函数，子构造函数需要依托主构造函数，会直接或者间接调用主构造函数，是继承的，可以通过 super 调用主构造函数  
主构造函数：在类的标题中，不手动表示系统会生成默认一个无参的  
子构造函数：在类内部，用 constructor 表示，没有注解和可见性修饰符时可以省略关键字，但为 private 时不可省略  
# data class
数据类（只保存数据），自动生成：
equals；hashCode；toString；copy；componentN，kotlin特有解构声明，通过该方法可智能获取到传入的参数；属性的 get()/set()（用var修饰），@JvmField 可忽略对属性的方法生成；constructor，@JvmOverloads 自动生成多个构造函数的重载
# Null Safety
?（可空，不崩溃）；!!（非空）等符号，保证空指针安全，可以智能识别对象类型
# CallBack
若要重写的只有一个方法，则 lambda 表达式可以直接写方法体，此外若不使用传入的参数，则可以直接省略
# sealed class
密封类，枚举类的扩展，子类可以有多个对象，可以持有其他引用数据，可以自定义方法
# Componion
object：修饰的类为静态类，方法和变量均为静态，可声明静态内部类  
componion object：伴生对象，类中只存在一个，类似 java 静态方法、静态成员，调用的也必须是静态成员
# Coroutine

## Flow
建立在协程之上，顺序发出多个同一类型值，不只返回单个值的挂起函数，通过挂起函数异步生成和使用值  
1.提供方异步生成添加到数据流中的数据  
2.（可选）中介修改发送到数据流的值，或修正数据流本身  
3.使用方使用数据流中的值
