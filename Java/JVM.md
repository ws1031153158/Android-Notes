# 内存结构
Java 内存模型：所有变量都存在主存，线程有自己的工作内存。  
线程私有：  
虚拟机栈：线程每次调用方法会创建一个栈帧，结束时销毁，记录每个栈帧中的局部变量（表/数组），存放方法参数和方法内定义的局部变量，可通过索引直接访问指定成员、方法返回地址、常量池的相关引用（动态链接）以及操作数栈等。  
本地方法栈：调用操作系统原生方法需要的内存区域。  
程序计数器：记录线程当前执行的指令信息，执行到哪条，下一条是哪个。  
共享内容（JVM 启动时创建，退出时释放）：  
Java堆：存放实例对象，Arrays 实例等。  
方法区：JVM 具体实现，逻辑上可视为 Java 堆的一部分，存放类结构、类成员定义、静态成员等，含有一个运行时常量池，存放字符串、int 等，与 class 文件通过 classLoader 进行转换。  
此外，分为栈和堆主要是因为内存信息为两类，生命周期短，占用内存小的指令等，以及生命周期长，内存大，可以复用的实例对象等。  
# 类加载
## 类加载机制
加载过程为：加载 -> 链接（验证 -> 准备 -> 解析 -> 符号引用） -> 初始化 （-> 卸载）  。  
1..java 文件转化为 .class 文件。  
2.通过类全限定名获取到完整的字节码读入内存，此为本地内存，1.8 之前为 JVM 内存。  
3.堆内存(Java Heap)创建 Class 对象，作为 .class 进入内存后数据的访问入口。  
4.验证加载的字节流符合 JVM 的规范,不会对 JVM 有安全性问题,对符号引用的验证，是否符合规范，以及是否可以通过全限定名获取到。  
5.为类变量开辟空间并赋予默认值。  
6.将 Class 在常量池中的符号引用变为直接引用，其实就是字符串变为内存地址，针对静态和私有方法与属性，因为不能被重写，也没有多态，编译器可知，运行期不可变。  
7.给变量赋予初始值。  
8.若该类没被引用，且实例和类加载器被回收则该类的二进制数据会从内存中卸载。  
## 类加载器
ClassLoader：据类的全限定名读取此类的二进制字节流到JVM，转换为 .Class 对象实例  
Bootstrap：加载 JVM 自身需要的类，将核心类库或指定路径下的 jar 包加载到内存  
Extension：加载特定目录下或由系统变量指定位路径的类库  
System：加载系统类路径或指定路径下的类库  
# GC
## 引用类型
强引用：根路径直达，无论内存是否足够都不回收，JVM 停止才回收，用于维持对象一般状态，内存不足会直接抛异常，需要手动释放引用，如置为 null 或将其状态更改为 lifecycle 终止  
软引用：内存不足时回收，用于对象缓存，可以和构造时传入的引用队列关联，引用对象被回收将软引用加入引用队列，集中回收无效的软引用，可以用在 back 时缓存页面  
弱引用：不管当前内存空间足够与否，都会回收，用于对象缓存，也可关联引用队列，用于很少使用的对象，如 ThreadLocal  
虚引用：get 方法直接返回 null，无法获取到被引用的对象，指向对象没有被其他强引用所持有，任何时候都可以回收，被回收后虚引用本身加入到引用队列，记录对象已回收，用于跟踪对象的垃圾回收，使用虚引用管理堆外内存  
堆外内存：NIO 通过 byteBuffer.allocateDirect(size) 手动分配堆外内存、或反射获取 unSfae，通过 unSafe.allocateMemory 开辟堆外内存，byteBuffer 被虚引用对象 cleaner 引用，手动置为 null 后，虚引用加入引用队列，通过一个回收线程将队列中虚引用取出并调用 clean 方法，根据内存地址释放内存，不受 JVM GC 影响，需要手动回收。
## Algorithm
### 判断方式
#### 可达性分析
GC Root为起点，向下遍历，走过的路径为引用链，引用链包含的对象为可达  
GC Root范围包括：
1.本地方法栈中 JNI 引用  
2.静态变量引用：运行时常量池的引用型常量(String/Class)  
3.活跃线程引用：线程中正在被调用方法的引用型参数、局部变量、临时值、正在加载的类（虚拟机栈中栈帧相关引用）
#### 回收对象
需要GC的：运行时动态创建的，内存分配和回收不确定的，如 Java 堆、方法区（常量池）  
无需GC的：编译器可知内存占用的，内存分配和回收确定的，特点为随着线程的开启而创建，线程关闭销毁的，比如程序计数器、虚拟机栈、本地方法栈
### 回收算法
#### 标记清除（mark-sweep）
#### 标记拷贝（mark-copy）
#### 标记交换（mark-compact）
#### 分代收集（generation-collection）
## 内存碎片
内存分配后被占用，但是没有利用，持有者终止释放后才能再次被分配使用。可以理解为，剩余内存足够，但是不是连续的内存空间，导致一片一片的独立内存，无法放入大于这些独立内存的对象。
## 回收流程
首先申请新对象，如果 eden 放得下则分配内存，放不下则进行 minor GC， -此时 eden 放得下则分配内存，还是放不下但 old 放得下（大型新对象）则分配内存，若放不下则进行 Full GC，此时 old 放得下则分配内存，这都放不下直接 OOM。    
minor GC 后存活对象在年轻区放得下则放入 to/from 区，放不下则晋升 old，当对象存活超过阈值时也晋升old，若没超过则先放在 to/from 区。
### RSets
Region 和分代都采用 RSt 避免判断对象存活时对整个 Java 堆扫描，每个 Region/分代 个体都有一个对应的 RSet，GC 时在 GC Root（正在执行的方法调用链上的局部变量、静态变量指向的对象等）加入 RSet
### 写屏障
每次对引用数据 write 时，都产生一个 Write Barrier（暂停操作），检查将要写入的引用指向的对象是否和该引用数据在不同的 Region（老年代是否引用年轻代），不同则把相关引用信息记录到引用指向对象所在 Region 对应的 RSet
## STW
Java 线程被挂起，代码暂停，线程被挂起，native 可以运行但不能与 JVM 交互，可达性分析时会有此操作
# 堆内存
## 内存模型
### 分代模型
分为新生代和老年代，另外还有永久代。  
新生代：占用空间较老年代小些，经过了多次 Minor GC未 被回收的新生代会晋升为老年代。  
老年代：存活时间久，占用内存大。  
不同年代采用的回收策略和算法也不同，新生代多为 Minor GC，频率快，相对简单，老年代采用的 Full GC，耗时较久。
### 区域模型
内存区域越小，占用空间小，对象存活量小，GC 效率越高。  
基于 Region 的布局模型，老年代和新生代为一个区域的属性，每个区域大小相等，此外还有独占空间针对超过一个Region一半大小的超大型对象。
#### G1
面向大内存，多处理器的场景，并发 GC，且部分工作可以和程序同步执行，不会完全阻塞程序运行，通过 Region 的动态分配实现逻辑上的连续。  
可以预估每一次 Full GC 的时间，Region 大小一致，根据停顿时间可以算出此次 GC 回收 Region 的个数，无需全部清理，可以根据业务，针对某些 Region 回收，按照价值来回收，缩小范围提高效率。  
年轻代GC 会暂停应用线程，并发回收，将存活对象移动到老年区或另外的年轻代 survivor 区（to/from），接着老年代并发标记默认内存使用到45%，一次只扫描/回收一部分老年代， 之后会进行 Mixed GC，老年和年轻一起回收，其实就是针对 Rgion 回收，其实 Full GC 也存在，这种强力回收针对 GC 的评估失败提供保护机制，比如处理时空间耗尽了、回收时没有空间放下晋升的对象。  
回收的 Region 中存活对象会被复制到空的 Region，除并发标记外，其他过程均会 STW。
#### ZCG
一般情况一个 Region 放不满会浪费，因此有了更精细的管理将 Region 按照大中小区分，可动态调整 Region 大小，会产生更少的内存碎片和更大的内存利用率，以及对时间更加精准的管理。    
此外，不对 Region 分区，每次回收都是并发对所有 Region 执行，全并发 GC，标记、重定位、转移几乎都是并发执行，转移过程应用线程也可以访问对象，通过读屏障保证获取的地址正确，STW很短，减少更新记录开销以及记录内存占用。
##### 着色指针
将信息存储在指针，重新定义了虚拟内存和物理内存的映射关系，支持64位系统，将虚拟内存分为五个空间。  
0-4TB：Java Heap，创建对象时先在此申请，但不会映射到物理内存，他会对应 M0、M1、Remmaped 三个空间地址，并 同时在 M0、M1、Remmaped 申请一个虚拟地址，三个地址对应同一个物理地址，但是同一时间只有一个空间生效    
4-8TB：M0  
8-12TB：M1  
12-16TB：预留  
16-20TB：Remmaped  
实际只使用 42 位（0-41），所以可分配最大内存为 4TB（42 位最大寻址空间），此外，42-45 就是 color pointers，42/43/44 分别设置 1 则表示采用对应的视图，对应不同的地址空间，存储对象存活信息，不放在对象头中了，47-63 位固定为 0
##### 读屏障
JVM 向应用插入代码，当应用线程从堆中读取对象引用时执行，对象标记和转移时，确定对象的引用地址是否满足条件，不满足需要更新地址信息，将从堆中对象的引用读取的指针更新到对象的新地址上，无需STW。
初始化：地址视图为Remapped。  
并发标记：第一次进入标记阶段视图为 M0，对象被 GC 标记线程或应用线程访问过，地址视图从 Remapped 到 M0，其中 M0 为活跃的，Remapped 视为不活跃。  
并发转移：地址视图再次设为 Remapped，对象被 GC 转移线程或者应用线程访问过，从 M0 到 Remapped。  
标记阶段存在两个地址视图 M0 和 M1，区别前一次标记和当前标记，第二次进入并发标记阶段，地址视图调整为 M1，不活跃的为 M0。  
着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；ZGC 只需设置指针地址 42~45 位即可，寄存器访问，速度比访问内存更快。
