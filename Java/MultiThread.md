# Build
Runnable：无返回值  
Callable：有返回值  
new Thread  新建线程对象  
ThreadPool：可控制并发条件，一般是通过 Executor 来构建的，也可获取系统的线程池使用  
线程优先级和属性会被继承，线程优先级和属性和开启他的线程的相同（父子关系）  
start 开启线程，无需主动 run（jvm 会调，主动调则相当于调了两次，也会执行两次）  ，join 用于等待其他线程执行结束（如 A 调用 B 的 join，A 进入等待状态直到 B 结束）
# ThreadPool
一般是通过 Executor 来构建的（顶级接口是 Executor，但其只是工具，真正接口是 ExecutorService），也可获取系统的线程池使用。  
1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。  
2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(线程需要内存，开的越多，消耗内存越大，最后死机)。
# Lock
## basic
JVM 给每个对象维护一个入口集（Entry Set，存储申请该对象内部锁的线程，如调用 notify 让对象等待集中的任一线程唤醒（可能造成假死（唤醒了未准备好的线程导致阻塞）），线程继续留在等待集，直到再次持有对应的内部锁，wait  把当前线程从等待集中移除）和等待集（Wait Set，存储对象上的等待线程，如 wait 将线程暂停(需和 while 一起使用)，释放内部锁时将线程存入对象等待集）。Lock.lock 不能放入 try（其他方法异常，finally 的 unlock 对未加锁对象解锁，调用 AQS.reyRelease 会抛出异常）。每个对象有一个 monitor 对象，就是这个对象的锁（对象锁），每个类也有个锁（类锁，通过对象锁实现，即Class的对象锁），自定义锁对象可以通过如 synchronized 方式，锁住代码块或某个对象。  
.lock/.unlock 实现加锁/解锁，一般使用 ReentrantLock（可重入/排他）/ReadWriteLock（多读一写，写则禁止读），代码实现，需要在 finally 中手动释放,tryLock 失败返回 false 不会等待。
## synchronized
托管给 JVM，锁升级流程为无锁到偏向锁（偏向启动（有 4s 延迟）则偏向锁/未启动则直接轻量级锁），再升级为（当锁是偏向锁的时候，却被另外的线程所访问则升级）轻量级锁（自旋（自适应则自旋时间不固定，根据同一锁的自选时间及拥有者的状态决定）+ CAS 的方式来抢锁，如果之前是偏向锁，则需要先将标记清除（计数器）），再上升到（多个线程用一个锁，某个达到最大自旋次数的线程会升级锁）重量级锁（线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态，线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起，操作系统来负责线程间的调度和线程的状态变更）。可对代码块、类、方法使用。  
一个线程访问对象的 synchronized 方法，其他线程不能访问该对象的其他 synchronized 方法，但可以访问非 synchronized 方法。（可以访问该对象的静态 synchronized 方法，因为持有的是类锁）。  
对于同步代码块，有一个互斥的入口和互斥的出口：  
monitorEnter：  
入口，加锁时，对象的 monitor 被锁定，monitorEnter 获取 monitor 权限，将进入数 +1（原来为 0 变为 1，原来是 1（已被锁定），如果是重新进入，进入数 +1，如果是被其他线程占用，则等变为 0 才进入）。  
monitorExit：  
出口，有两个，一个正常一个异常。执行时，进入数 -1，如果为 0 则线程退出 monitor。  
对于同步方法，JVM 通过常量池中的 ACC_SYNCHRONIZED 标识符实现同步（判断是否被设置，是则先获取 monitor，成功后才执行），通过出/入两个指令来进行操作，实例方法对应锁对象 this（对象锁），静态方法对应所在类的 Class 实例（类锁）。
## volatile
计算机执行程序时，每条指令都是在 CPU 中执行的，执行指令过程中的临时数据是存放在主存（物理内存）当中的，CPU 执行速度很快，从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比要慢，对数据的操作通过和内存的交互来进行降低执行速度，因此 CPU 有了高速缓存。运行过程中，将运算需要的数据从主存复制一份到 CPU 的高速缓存，计算时直接从缓存读取数据和写入，运算结束后将缓存的数据刷新到主存当中，多核 CPU 中，每条线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存（单核 CPU 也会出现这种问题，不过是以线程调度来分别执行的）。  
此关键字用于修饰对象，使其修改对其他线程可见，把修改后的值更新到主存（锁定当前内存区域的缓存，将当前缓存数据写入主存，使其他线程缓存该变量的地址失效，导致其他需要重新去主存中读取数据），相当于每次读都是从主存读取（Java共享变量存在主存，线程无法直接访问主存，要把数据读到本地（拷贝副本），修改数据写回主存。），保证可见性和有序性。  
## 可重入性
一个线程得到一个对象锁后再次请求该对象锁，是允许的（子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法）
## ReentrantLock
默认非公平（允许插队），内部使用 AQS 实现竞争，未竞争到的会加入AQS的同步队列（双向链表 FIFO）
## DCL
双检索，不一定线程安全（new 会发生指令重排（1.分配内存 2.初始化对象 3.变量赋值，顺序会变为 1.3.2）），可通过 volatile 解决
## Automic
与 Synchronized 相反，是乐观锁，采用 CAS 方式保证线程安全，只针对变量，保证原子性和可见性。  
乐观锁其实是无锁，操作时不会加锁（假设不会有其他线程参与），修改完成会检查过程中是否有其他线程参与，有则放弃这次操作。
## CAS
CAS(V,A,B)。V 要更新的变量(内存值)，A 预期值，B 新值。 V 值等于 A 值时将 V 值设为 B，不同则已有其他线程更新，当前线程什么都不做（需要取出内存中某时刻的数据，而在下一时刻比较并替换，时间差类会导致数据的变化，也就是 ABA，无感知的多次替换，可通过版本号控制）
## AQS
对重入锁、读写锁、计数锁提供基础框架，内部定义了获取和释放同步状态的模板方法,留下钩子函数供子类继承扩展，通过同步队列（双向链表）管理获取同步状态失败的线程（加入尾部并阻塞自身，首节点为正在获取锁的线程，释放锁时尝试唤醒阻塞态的线程），维护一个 state 记录重入次数（首节点线程）
## Condition
Condition 实例是一个条件变量， 内部维护用于存储等待线程的等待队列，相当于 Object 的等待集。  
实现等待/通知，await/signal 判断唤醒条件是否成立，不存在过早唤醒，会根据 awaitUntil 返回值不同来区分是由于等待超时还是被通知线程唤醒，不存在无法区分问题。    
 await/signal/signalAll（要求线程持有 Condition 实例的显示锁）相当于 Object 的 wait/notify/notifyAll（要求线程持有所属对象内部锁）
# Interrupt
方法结束线程使用 interrupt 方法中断，线程处于阻塞状态调用 interrupt 阻塞方法抛 InterruptException 异常，捕获该异常后 break 跳出循环结束线程。未处于阻塞状态，使用 isInterrupted 确定线程中断标志来退出循环，使用 interrupt 中断标志置为true，也可以自定义标志控制。
# Class
daemon：用于执行不重要任务，如监控其他线程运行情况，GC 线程就是一个守护线程，JVM 退出时不会考虑是否执行完成，在线程启动前设置 setDaemon(true) 。  
user：JVM 退出时，所有用户线程都执行完毕，则退出
# Automic
硬件提供原子操作指令（++i 和 i++ 不是线程安全），开销更小，速度更快，线程安全，内部使用 volitale 标识参数，通过比较替换进行更新，有效避免死锁和优先级倒置。
