# Build
Runnable：无返回值  
Callable：有返回值  
new Thread  新建线程对象  
ThreadPool：可控制并发条件，一般是通过 Executor 来构建的，也可获取系统的线程池使用  
线程优先级和属性会被继承，线程优先级和属性和开启他的线程的相同（父子关系）  
start 开启线程，无需主动 run（jvm 会调，主动调则相当于调了两次，也会执行两次）  ，join 用于等待其他线程执行结束（如 A 调用 B 的 join，A 进入等待状态直到 B 结束），start 会开启一个新的线程，调用 run 也还是在当前线程，会阻塞
# ThreadPool
一般是通过 Executor 来构建的（顶级接口是 Executor，但其只是工具，真正接口是 ExecutorService），也可获取系统的线程池使用。  
1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。  
2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(线程需要内存，开的越多，消耗内存越大，最后死机)。
# ThreadLocal
线程本地变量，访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量，实际是在操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了并发场景下的线程安全问题，一种空间换时间的方式   
Thread 线程类有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，每个线程都有一个自己的 ThreadLocalMap，内部维护了 Entry 数组，每个 Entry 代表一个完整的对象，key 是 ThreadLocal 本身，value 是 ThreadLocal 的泛型对象值，并发多线程场景下，每个线程 Thread，在往 ThreadLocal 里设置值的时候，都是往自己的 ThreadLocalMap 里存，读也是以某个 ThreadLocal 作为引用，在自己的 map 里找对应的 key，从而可以实现了线程隔离  
使用完，要手动调用 remove，否则可能会内存泄漏：ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key，当 ThreadLocal 变量被手动设置为 null，即一个 ThreadLocal 没有外部强引用来引用它，GC 时，ThreadLocal 一定会被回收，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value，如果当前线程再迟迟不结束的话(比如线程池的核心线程)，这些 value 就会一直存在一条强引用链：Thread 变量 -> Thread 对象 -> ThreaLocalMap -> Entry -> value -> Object 永远无法回收，造成内存泄漏
# Lock
## basic
JVM 给每个对象维护一个入口集（Entry Set，存储申请该对象内部锁的线程，如调用 notify 让对象等待集中的任一线程唤醒（可能造成假死（唤醒了未准备好的线程导致阻塞）），线程继续留在等待集，直到再次持有对应的内部锁，wait  把当前线程从等待集中移除）和等待集（Wait Set，存储对象上的等待线程，如 wait 将线程暂停(需和 while 一起使用)，释放内部锁时将线程存入对象等待集）。Lock.lock 不能放入 try（其他方法异常，finally 的 unlock 对未加锁对象解锁，调用 AQS.reyRelease 会抛出异常）。每个对象有一个 monitor 对象，就是这个对象的锁（对象锁），每个类也有个锁（类锁，通过对象锁实现，即Class的对象锁），自定义锁对象可以通过如 synchronized 方式，锁住代码块或某个对象。  
.lock/.unlock 实现加锁/解锁，一般使用 ReentrantLock（可重入/排他）/ReadWriteLock（多读一写，写则禁止读），代码实现，需要在 finally 中手动释放,tryLock 失败返回 false 不会等待。
## synchronized
托管给 JVM，锁升级流程为无锁到偏向锁（偏向启动（有 4s 延迟）则偏向锁/未启动则直接轻量级锁），再升级为（当锁是偏向锁的时候，却被另外的线程所访问则升级）轻量级锁（自旋（自适应则自旋时间不固定，根据同一锁的自选时间及拥有者的状态决定）+ CAS 的方式来抢锁，如果之前是偏向锁，则需要先将标记清除（计数器）），再上升到（多个线程用一个锁，某个达到最大自旋次数的线程会升级锁）重量级锁（线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态，线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起，操作系统来负责线程间的调度和线程的状态变更）。可对代码块、类、方法使用。  
一个线程访问对象的 synchronized 方法，其他线程不能访问该对象的其他 synchronized 方法，但可以访问非 synchronized 方法。（可以访问该对象的静态 synchronized 方法，因为持有的是类锁）。  
对于同步代码块，有一个互斥的入口和互斥的出口：  
monitorEnter：  
入口，加锁时，对象的 monitor 被锁定，monitorEnter 获取 monitor 权限，将进入数 +1（原来为 0 变为 1，原来是 1（已被锁定），如果是重新进入，进入数 +1，如果是被其他线程占用，则等变为 0 才进入）。  
monitorExit：  
出口，有两个，一个正常一个异常。执行时，进入数 -1，如果为 0 则线程退出 monitor。  
对于同步方法，JVM 通过常量池中的 ACC_SYNCHRONIZED 标识符实现同步（判断是否被设置，是则先获取 monitor，成功后才执行），通过出/入两个指令来进行操作，实例方法对应锁对象 this（对象锁），静态方法对应所在类的 Class 实例（类锁）。
## volatile
计算机执行程序时，每条指令都是在 CPU 中执行的，执行指令过程中的临时数据是存放在主存（物理内存）当中的，CPU 执行速度很快，从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比要慢，对数据的操作通过和内存的交互来进行降低执行速度，因此 CPU 有了高速缓存。运行过程中，将运算需要的数据从主存复制一份到 CPU 的高速缓存，计算时直接从缓存读取数据和写入，运算结束后将缓存的数据刷新到主存当中，多核 CPU 中，每条线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存（单核 CPU 也会出现这种问题，不过是以线程调度来分别执行的）。  
此关键字用于修饰对象，使其修改对其他线程可见，把修改后的值更新到主存（锁定当前内存区域的缓存，将当前缓存数据写入主存，使其他线程缓存该变量的地址失效，导致其他需要重新去主存中读取数据），相当于每次读都是从主存读取（Java共享变量存在主存，线程无法直接访问主存，要把数据读到本地（拷贝副本），修改数据写回主存。），保证可见性和有序性，不保证原子性。  
## 可重入性
一个线程得到一个对象锁后再次请求该对象锁，是允许的（子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法）
## ReentrantLock
默认非公平（允许插队），内部使用 AQS 实现竞争，未竞争到的会加入 AQS 的同步队列（双向链表 FIFO）
## DCL
双检索，不一定线程安全（new 会发生指令重排（1.分配内存 2.初始化对象 3.变量赋值，顺序会变为 1.3.2）），可通过 volatile 解决
## Automic
与 Synchronized 相反，是乐观锁，采用 CAS 方式保证线程安全，只针对变量，保证原子性和可见性。  
乐观锁其实是无锁，操作时不会加锁（假设不会有其他线程参与），修改完成会检查过程中是否有其他线程参与，有则放弃这次操作。
## CAS
CAS(V,A,B)。V 要更新的变量(内存值)，A 预期值，B 新值。 V 值等于 A 值时将 V 值设为 B，不同则已有其他线程更新，当前线程什么都不做（需要取出内存中某时刻的数据，而在下一时刻比较并替换，时间差类会导致数据的变化，也就是 ABA，无感知的多次替换，可通过版本号控制）
## AQS
数据结构的核心就是两个队列，一个是同步队列 sync queue，一个是条件队列 condition queue  
对重入锁、读写锁、计数锁提供基础框架，内部定义了获取和释放同步状态的模板方法,留下钩子函数供子类继承扩展，通过同步队列（双向链表）管理获取同步状态失败的线程（加入尾部并阻塞自身，首节点为正在获取锁的线程，释放锁时尝试唤醒阻塞态的线程），维护一个 state 记录重入次数（首节点线程）  
维护一个共享状态，分为两种模式，一种是独占模式，一种是共享模式  
tryAcquire 独占模式，尝试获取资源，成功则返回 true，失败则返回 false
tryAcquireShared 共享方式，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源
## Condition
Condition 实例是一个条件变量， 内部维护用于存储等待线程的等待队列，相当于 Object 的等待集。  
实现等待/通知，await/signal 判断唤醒条件是否成立，不存在过早唤醒，会根据 awaitUntil 返回值不同来区分是由于等待超时还是被通知线程唤醒，不存在无法区分问题。    
 await/signal/signalAll（要求线程持有 Condition 实例的显示锁）相当于 Object 的 wait/notify/notifyAll（要求线程持有所属对象内部锁）
 ## Cyclicbarrier
 1.CyclicBarrier 的构造函数有 2 个参数，第 1 个参数是声明有几件事情完成之后才能开始另外一件事情（有几件事可以并行），第 2 个参数是一个 Runnable，此参数代表并行完之后要做的事情  
2.每个部件造完后调用 CyclicBarrier.await 方法等待启动下一轮  
3.当最后一个部件造完后则会自动调用 CyclicBarrier 构造函数中传入的 Runnable 的实现类  
4.Runnable 实现类实现完成后重新开始下一轮    
 ## CountDownLaunch
 使一个线程在等待另外一些线程完成各自工作之后，再继续执行。它相当于是一个计数器，这个计数器的初始值就是线程的数量（构造函数的参数），每当一个任务完成后，计数器的值就会减一（countDown），当计数器的值为 0 时，表示所有的线程都已经任务了，然后在 CountDownLatch 上等待的线程就可以恢复执行接下来的任务（ await 的线程就会被唤醒），也可以延迟唤醒，加一个延迟时间就可以实现，底层是 AQS  
 与 Cyclicbarrier 的区别   
1）CyclicBarrier 的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值 -1 而已，该线程继续运行  
2）CyclicBarrier 只能唤起一个任务，CountDownLatch 可以唤起多个任务  
3) CyclicBarrier 可重用，CountDownLatch 不可重用，计数值为 0 该 CountDownLatch 就不可再用了
## BlockingQueue
基于阻塞机制实现的线程安全的队列，阻塞机制的实现是通过在入队和出队时加锁的方式避免并发操作   
1.通过在入队和出队时进行加锁，保证了队列线程安全   
2.支持阻塞的入队和出队方法：当队列满时，会阻塞入队的线程，直到队列不满；当队列为空时，会阻塞出队的线程，直到队列中有元素   
### ArrayBlockingQueue
基于数组的阻塞队列，使用数组存储数据，并需要指定其长度，所以是一个有界队列   
add 方法入队元素，如果无空间则抛出异常；put 方法入队元素，如果无空间则会一直阻塞  
remove 方法出队元素，如果无元素则抛出异常  
take 方法出队元素，如果无元素则一直阻塞  
使用独占锁 ReentrantLock 实现线程安全，入队和出队操作使用同一个锁对象，也就是只能有一个线程可以进行入队或者出队操作，这也就意味着生产者和消费者无法并行操作，在高并发场景下会成为性能瓶颈
# Interrupt
方法结束线程使用 interrupt 方法中断，线程处于阻塞状态调用 interrupt 阻塞方法抛 InterruptException 异常，捕获该异常后 break 跳出循环结束线程。未处于阻塞状态，使用 isInterrupted 确定线程中断标志来退出循环，使用 interrupt 中断标志置为true，也可以自定义标志控制。
# Class
daemon：用于执行不重要任务，如监控其他线程运行情况，GC 线程就是一个守护线程，JVM 退出时不会考虑是否执行完成，在线程启动前设置 setDaemon(true) 。  
user：JVM 退出时，所有用户线程都执行完毕，则退出
# Automic
硬件提供原子操作指令（++i 和 i++ 不是线程安全），开销更小，速度更快，线程安全，内部使用 volitale 标识参数，通过比较替换进行更新，有效避免死锁和优先级倒置。
# Tips
1.线程出现 runtimeException 会停止运行，如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放   
2.sleep 和 wait 都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器   
3.final 或者说不可变对象，相当于保证了内存可见，读取时无需进行同步的操作，避免消耗
