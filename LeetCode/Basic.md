# Hash
Map、Set，不重复的集合作为某种标准，map 类似，值可以重复  
# Array
反转、temp、给定k次，或某个确定值，先看是否需要取余，分治法，对于某一个指定位置或其他阈值，分为左右分别处理  
类型为数组，且返回为数组时，需要注意写法，如 return list.toArray(new int[list.size()][])
# ArrayList
new ArrayList<>() 构造时，括号中可以直接传入参数类型匹配的集合，如 map.values  
类型为数组，且返回为数组时，要注意写法，如 return list.toAray(new int[list.size()][])，add 时也不一样，如 list.add(nums[1], nums)
# 最大公约数
（a(x, y) -> y > 0 ? a(y, x % y) : x  
# 裴蜀定理
对任何整数 a、b 和它们的最大公约数 d，	对于任意整数 x，y，ax + by 都一定是 d 的倍数，	一定存在整数 x，y，使 ax + by = d 成立  
# Tree
dfs、bfs，构建时考虑 hashmap，给节点加上编号，记录数量等问题时可以考虑  
# 动态规划
下一步由上一步推出，一般会有公式  
需要注意 dp 的范围，是 n 还是 n + 1，此外，这个 n 也要注意选取集合的 n 还是目标的 n
## 背包问题
是否可以根据一个 target（直接给出或间接求出），target 可以是数字也可以是字符串，再给定一个数组 arrs，问：能否使用 arrs 中的元素做各种排列组合得到 target
### 01
一共有 N 件物品，第 i（i 从 1 开始）件物品的重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限 W 的情况下，能够装入背包的最大价值  
外循环遍历 arrs，内循环遍历 target，且内循环倒序
### 完全
一共有 N 种物品，每种物品有无限多个，第 i（i 从 1 开始）种物品的重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限 W 的情况下，能够装入背包的最大价值  
1.不考虑元素之间顺序，arrs 放在外循环（保证 arrs 按顺序），target在内循环，且内循环正序  
2.考虑元素之间的顺序，需将 target 放在外循环，将 arrs 放在内循环，且内循环正序
# 贪心
求最优，每一步都采取当前最优解 
# 前缀和
1.求某一段区间元素之和，或某个属性的和/次数等，可以直接 s[n] = a[1] +...+a[n] 求前缀和，也可以 x = s[n] - s[3] 求具体某一段，具体求法为一种动态规划 s[n] = s[n - 1] + a[n]  
2.只要是求某种连续空间的答案，都可以考虑前缀和
# 字典树
前缀树 trie，存储和检索字符串数据集中的键  
class Trie {  
        Map<Character, Trie> child;//key类型可变  
        public Trie() {  
            child = new HashMap<>();  
        }  
    }  
# 时间复杂度
20 ——2^n  
50——n^4  
200——n^3  
2000——n^2  
20000——nlogn  
50000——n  
没有范围则从 n 开始，一般为 n——nlogn，有可能要累加考虑，如排序 + 双指针为 n*n  
n：数组：差分、前缀和、双指针、排序、单调栈、单调队列（滑动窗口）  
# 树/图
dfs/bfs、拓扑排序、字典树（前缀树 trie）  
# nlogn
最短路径、二叉搜索树、归并排序、快排、堆、最小生成树、ST表、线段树、树状数组  
# logn
二分、并查集、快速幂、最大公因数     
# PriorityQueue
给每个元素都分配一个数字来标记其优先级，设较小数字具有较高优先级，这样就可以在一个集合中访问优先级最高的元素并对其进行查找和删除操作，保证每次出队都是最大或最小元素（取决于对 Comparator.compare 的重写）。此外，不能插入 null，空间不足会自动扩容。     
# 堆
其实就是完全二叉树（某节点值总是不大于或不小于父节点值）进了一些调整，
# 快慢指针
1.head 不是虚节点，fast 需要注意初始化可能是 head.next，while 为 slow != fast，如找链表中点   
2.判断环时，fast = head，while 为 fast != null
3.可以由处理环的问题，演变为处理数组的问题，下标和数值进行映射，造一个链表出来，若有重复数则说明有环，找入环点即可，如 s = s.next、s = s.next.next 可以分别演变为 i = nums[i]、j = nums[nums[j]]
# 位运算
n & n - 1：表示二进制数去掉最右边的一个 1
n & 1：表示对 2 取余
0 与 任何数 ^ 都等于数本身
任何数与自身 ^ 都等于 0
# 回溯
需要求出解集（全部解），或者要求回答什么解是满足某些约束条件的最优解时（比如要求一种方法，从集合中挑几个出来满足条件）,往往要使用回溯法  
if (index == n) {  
  do something  
} else {  
  for () {  
    add(index)  
    backtrack(index + 1)  
    remove(index)  
  }  
}    
1.需要注意递归结束条件  
2.需要注意怎么递归，比如直接递归，还是要遍历递归（比如无序数组，找一个特定集合）
## Tips
1.temp 为 List，res 也为 List 时，res.add 需要为 add(new ArrayList<>(temp))  
2.一般 temp 为 int，则 remove 的是 temp.size() - 1，如果为 char，则是 deleteCharAt(index)
# 链表
哑巴节点：dummy 的 next 指向 head，这样无需判断头节点特殊情况（需要 pre 的时候）  
栈：先将节点入栈，当指定位置再出栈  
快慢指针：环、类似栈（找指定位置，n + m = m + n）
# 二分
while 的条件需要是 l <= r   
可以根据记录比 mid 大、小的数，根据数量来判断大部分数比 mid 大还是小，再进行下一步处理
# 字母异位词
一般可以通过各个字母数量相同来判断，也可以直接 toCharArray，排序后相同来判断
## 上下界
1.树的遍历需要注意上下界问题，如二叉搜索树  
2.数组的左右边界，以及开闭区间在特定场景也要注意
# String
s.substring(i, j) 是左开右闭，取 i + 1 到 j
# 岛屿问题
考虑 DFS  
遍历：四个方向  
base case：res[i][j] 会出现数组下标越界、不需要继续遍历的情况  
tips：需要额外注意是否已经遍历过了
# 拓扑排序
给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G 中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面，那么称该排列是图 G 的「拓扑排序」  
1.图 G 中存在环（即图 G 不是「有向无环图」），那么图 G 不存在拓扑排序  
2.如果图 G 是有向无环图，那么它的拓扑排序可能不止一种，如图 G 包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序  
其实就是把一个有向无环图转换为一个线性排序，能满足序列中所有的指向关系，每次向线性排序中添加的节点需要是入度为 0 的，且加入后，此节点指向的节点入度需要减 1
# Trie
前缀树，每个节点都记录当前是否为一个字符串的末尾，以及一个 26 大小的 next 数组，初始节点 root 为空，插入时，若 next 中对应的 next[char - 'a'] 为空则 new 一个 Node，否则说明有前缀，继续下一个循环即可  
搜索字符串或前缀的方法一致，遍历要搜索的字符串，挨个判断是否为空即可
# 快排
每次获取一个下标，小于它的在左边，大于在右边，然后对这两个分段继续递归排序，因为是原址排序所以无需再合并，完成后数组就是有序的  
需要注意，如果要求某个下标的值如第 K 大的值，那么在排序过程中即可提前找到结束
# 分治
对于数组或链表等结构，需要计算和、积，或者找某个数，可以以下标 i 为节点，分别处理左边和右边的数据，如累乘除本身之外的数时，可以设 res[0] = 1，r = 1，然后分别从两端开始，乘以 nums[i - 1]
# DFS
基本就是用于树、图  
返回的值可以不止是单一的数值，也可以返回一个数组，一个列表等，不要局限思维  
需要确定要 dfs 是什么，是 dfs 本身，还是方法本身
# 数组
1.不要只局限于基本数据类型的数据，数组类型也可以是个 List，但要注意初始化有些不同，如 List<Integer>[] l = new List[n]  
2.Arrays.sort 使用 lambda 时，注意时 () 不是 {}，此外传入的是数组本身，如 Arrays.sort(nums, (n1, n2) -> (n1 - n2))，如果是二维数组，则是 (n1[0] - n2[0]) 或者 (n1[1] - n2[1])，左 - 右 -> 为顺序  
3.需要求某种顺序或顺序关系时，考虑是不是可以针对下标操作，比如比较数值后将下标存起来，后续返回  
4.字母相关的集合，可以考虑直接创建一个大小为 26 的集合出来，可以计算每个字母的数量等参数，如 alp[char - 'A']++，此外，需要注意的是，char 转换为字母需要执行 char - 'A'/'a'  
5.一次遍历，可以记录最大值、最小值，不断去更新
