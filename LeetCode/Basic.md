Hash：Map、Set，不重复的集合作为某种标准，map 类似，值可以重复  
Array：反转、temp、给定k次，或某个确定值，先看是否需要取余，分治法，对于某一个指定位置或其他阈值，分为左右分别处理  
最大公约数（a(x, y) -> y > 0 ? a(y, x % y) : x  
裴蜀定理：对任何整数 a、b 和它们的最大公约数 d，	对于任意整数 x，y，ax + by 都一定是 d 的倍数，	一定存在整数 x，y，使 ax + by = d 成立  
tree：dfs、bfs，构建时考虑 hashmap，给节点加上编号，记录数量等问题时可以考虑  
动态规划：下一步由上一步推出，一般会有公式  
贪心：求最优  
前缀和：求某一段区间元素之和，或某个属性的和/次数等，可以直接 s[n] = a[1] +...+a[n] 求前缀和，也可以 x = s[n] - s[3] 求具体某一段，具体求法为一种动态规划 s[n] = s[n - 1] + a[n]  
字典树（前缀树trie）：存储和检索字符串数据集中的键  
class Trie {  
        Map<Character, Trie> child;//key类型可变  
        public Trie() {  
            child = new HashMap<>();  
        }  
    }  
20 ——2^n  
50——n^4  
200——n^3  
2000——n^2  
20000——nlogn  
50000——n  
没有范围则从 n 开始，一般为 n——nlogn，有可能要累加考虑，如排序 + 双指针为 n*n  
n：数组：差分、前缀和、双指针、排序、单调栈、单调队列（滑动窗口）  
树/图：dfs/bfs、拓扑排序、字典树（前缀树 trie）  
nlogn：最短路径、二叉搜索树、归并排序、快排、堆、最小生成树、ST表、线段树、树状数组  
logn：二分、并查集、快速幂、最大公因数  
